{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChannelImplementation = void 0;\n\nconst call_stream_1 = require(\"./call-stream\");\n\nconst channel_credentials_1 = require(\"./channel-credentials\");\n\nconst resolving_load_balancer_1 = require(\"./resolving-load-balancer\");\n\nconst subchannel_pool_1 = require(\"./subchannel-pool\");\n\nconst picker_1 = require(\"./picker\");\n\nconst constants_1 = require(\"./constants\");\n\nconst filter_stack_1 = require(\"./filter-stack\");\n\nconst call_credentials_filter_1 = require(\"./call-credentials-filter\");\n\nconst deadline_filter_1 = require(\"./deadline-filter\");\n\nconst compression_filter_1 = require(\"./compression-filter\");\n\nconst resolver_1 = require(\"./resolver\");\n\nconst logging_1 = require(\"./logging\");\n\nconst max_message_size_filter_1 = require(\"./max-message-size-filter\");\n\nconst http_proxy_1 = require(\"./http_proxy\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nconst connectivity_state_1 = require(\"./connectivity-state\");\n\nconst channelz_1 = require(\"./channelz\");\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\n\n\nconst MAX_TIMEOUT_TIME = 2147483647;\nlet nextCallNumber = 0;\n\nfunction getNewCallNumber() {\n  const callNumber = nextCallNumber;\n  nextCallNumber += 1;\n\n  if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n    nextCallNumber = 0;\n  }\n\n  return callNumber;\n}\n\nclass ChannelImplementation {\n  constructor(target, credentials, options) {\n    var _a, _b, _c;\n\n    this.credentials = credentials;\n    this.options = options;\n    this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n    this.currentPicker = new picker_1.UnavailablePicker();\n    /**\n     * Calls queued up to get a call config. Should only be populated before the\n     * first time the resolver returns a result, which includes the ConfigSelector.\n     */\n\n    this.configSelectionQueue = [];\n    this.pickQueue = [];\n    this.connectivityStateWatchers = [];\n    this.configSelector = null; // Channelz info\n\n    this.channelzEnabled = true;\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n\n    if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n      throw new TypeError('Channel credentials must be a ChannelCredentials object');\n    }\n\n    if (options) {\n      if (typeof options !== 'object') {\n        throw new TypeError('Channel options must be an object');\n      }\n    }\n\n    this.originalTarget = target;\n    const originalTargetUri = uri_parser_1.parseUri(target);\n\n    if (originalTargetUri === null) {\n      throw new Error(`Could not parse target name \"${target}\"`);\n    }\n    /* This ensures that the target has a scheme that is registered with the\n     * resolver */\n\n\n    const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);\n\n    if (defaultSchemeMapResult === null) {\n      throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n    }\n\n    this.callRefTimer = setInterval(() => {}, MAX_TIMEOUT_TIME);\n    (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n\n    this.channelzTrace = new channelz_1.ChannelzTrace();\n\n    if (this.channelzEnabled) {\n      this.channelzRef = channelz_1.registerChannelzChannel(target, () => this.getChannelzInfo());\n      this.channelzTrace.addTrace('CT_INFO', 'Channel created');\n    } else {\n      // Dummy channelz ref that will never be used\n      this.channelzRef = {\n        kind: 'channel',\n        id: -1,\n        name: ''\n      };\n    }\n\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'];\n    } else {\n      this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);\n    }\n\n    const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options);\n    this.target = proxyMapResult.target;\n    this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n     * the grpc.use_local_subchannel_pool channel option means. */\n\n    this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== void 0 ? _c : 0) === 0);\n    const channelControlHelper = {\n      createSubchannel: (subchannelAddress, subchannelArgs) => {\n        const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());\n        }\n\n        return subchannel;\n      },\n      updateState: (connectivityState, picker) => {\n        this.currentPicker = picker;\n        const queueCopy = this.pickQueue.slice();\n        this.pickQueue = [];\n        this.callRefTimerUnref();\n\n        for (const {\n          callStream,\n          callMetadata,\n          callConfig,\n          dynamicFilters\n        } of queueCopy) {\n          this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n        }\n\n        this.updateState(connectivityState);\n      },\n      requestReresolution: () => {\n        // This should never be called.\n        throw new Error('Resolving load balancer should never call requestReresolution');\n      },\n      addChannelzChild: child => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.refChild(child);\n        }\n      },\n      removeChannelzChild: child => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.unrefChild(child);\n        }\n      }\n    };\n    this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, configSelector => {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');\n      }\n\n      this.configSelector = configSelector;\n      /* We process the queue asynchronously to ensure that the corresponding\n       * load balancer update has completed. */\n\n      process.nextTick(() => {\n        const localQueue = this.configSelectionQueue;\n        this.configSelectionQueue = [];\n        this.callRefTimerUnref();\n\n        for (const {\n          callStream,\n          callMetadata\n        } of localQueue) {\n          this.tryGetConfig(callStream, callMetadata);\n        }\n\n        this.configSelectionQueue = [];\n      });\n    }, status => {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' + status.code + ' and details \"' + status.details + '\"');\n      }\n\n      if (this.configSelectionQueue.length > 0) {\n        this.trace('Name resolution failed with calls queued for config selection');\n      }\n\n      const localQueue = this.configSelectionQueue;\n      this.configSelectionQueue = [];\n      this.callRefTimerUnref();\n\n      for (const {\n        callStream,\n        callMetadata\n      } of localQueue) {\n        if (callMetadata.getOptions().waitForReady) {\n          this.callRefTimerRef();\n          this.configSelectionQueue.push({\n            callStream,\n            callMetadata\n          });\n        } else {\n          callStream.cancelWithStatus(status.code, status.details);\n        }\n      }\n    });\n    this.filterStackFactory = new filter_stack_1.FilterStackFactory([new call_credentials_filter_1.CallCredentialsFilterFactory(this), new deadline_filter_1.DeadlineFilterFactory(this), new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options), new compression_filter_1.CompressionFilterFactory(this, this.options)]);\n    this.trace('Channel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n\n  getChannelzInfo() {\n    return {\n      target: this.originalTarget,\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists()\n    };\n  }\n\n  trace(text, verbosityOverride) {\n    logging_1.trace(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + uri_parser_1.uriToString(this.target) + ' ' + text);\n  }\n\n  callRefTimerRef() {\n    var _a, _b, _c, _d; // If the hasRef function does not exist, always run the code\n\n\n    if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n      this.trace('callRefTimer.ref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n      (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n    }\n  }\n\n  callRefTimerUnref() {\n    var _a, _b; // If the hasRef function does not exist, always run the code\n\n\n    if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n      this.trace('callRefTimer.unref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n      (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n\n  pushPick(callStream, callMetadata, callConfig, dynamicFilters) {\n    this.pickQueue.push({\n      callStream,\n      callMetadata,\n      callConfig,\n      dynamicFilters\n    });\n    this.callRefTimerRef();\n  }\n  /**\n   * Check the picker output for the given call and corresponding metadata,\n   * and take any relevant actions. Should not be called while iterating\n   * over pickQueue.\n   * @param callStream\n   * @param callMetadata\n   */\n\n\n  tryPick(callStream, callMetadata, callConfig, dynamicFilters) {\n    var _a, _b, _c;\n\n    const pickResult = this.currentPicker.pick({\n      metadata: callMetadata,\n      extraPickInfo: callConfig.pickInformation\n    });\n    this.trace('Pick result: ' + picker_1.PickResultType[pickResult.pickResultType] + ' subchannel: ' + ((_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) + ' status: ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.code) + ' ' + ((_c = pickResult.status) === null || _c === void 0 ? void 0 : _c.details));\n\n    switch (pickResult.pickResultType) {\n      case picker_1.PickResultType.COMPLETE:\n        if (pickResult.subchannel === null) {\n          callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Request dropped by load balancing policy'); // End the call with an error\n        } else {\n          /* If the subchannel is not in the READY state, that indicates a bug\n           * somewhere in the load balancer or picker. So, we log an error and\n           * queue the pick to be tried again later. */\n          if (pickResult.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {\n            logging_1.log(constants_1.LogVerbosity.ERROR, 'Error: COMPLETE pick result subchannel ' + pickResult.subchannel.getAddress() + ' has state ' + connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()]);\n            this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n            break;\n          }\n          /* We need to clone the callMetadata here because the transparent\n           * retry code in the promise resolution handler use the same\n           * callMetadata object, so it needs to stay unmodified */\n\n\n          callStream.filterStack.sendMetadata(Promise.resolve(callMetadata.clone())).then(finalMetadata => {\n            var _a, _b;\n\n            const subchannelState = pickResult.subchannel.getConnectivityState();\n\n            if (subchannelState === connectivity_state_1.ConnectivityState.READY) {\n              try {\n                const pickExtraFilters = pickResult.extraFilterFactories.map(factory => factory.createFilter(callStream));\n                pickResult.subchannel.startCallStream(finalMetadata, callStream, [...dynamicFilters, ...pickExtraFilters]);\n                /* If we reach this point, the call stream has started\n                 * successfully */\n\n                (_a = callConfig.onCommitted) === null || _a === void 0 ? void 0 : _a.call(callConfig);\n                (_b = pickResult.onCallStarted) === null || _b === void 0 ? void 0 : _b.call(pickResult);\n              } catch (error) {\n                if (error.code === 'ERR_HTTP2_GOAWAY_SESSION') {\n                  /* An error here indicates that something went wrong with\n                   * the picked subchannel's http2 stream right before we\n                   * tried to start the stream. We are handling a promise\n                   * result here, so this is asynchronous with respect to the\n                   * original tryPick call, so calling it again is not\n                   * recursive. We call tryPick immediately instead of\n                   * queueing this pick again because handling the queue is\n                   * triggered by state changes, and we want to immediately\n                   * check if the state has already changed since the\n                   * previous tryPick call. We do this instead of cancelling\n                   * the stream because the correct behavior may be\n                   * re-queueing instead, based on the logic in the rest of\n                   * tryPick */\n                  this.trace('Failed to start call on picked subchannel ' + pickResult.subchannel.getAddress() + ' with error ' + error.message + '. Retrying pick', constants_1.LogVerbosity.INFO);\n                  this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                } else {\n                  this.trace('Failed to start call on picked subchanel ' + pickResult.subchannel.getAddress() + ' with error ' + error.message + '. Ending call', constants_1.LogVerbosity.INFO);\n                  callStream.cancelWithStatus(constants_1.Status.INTERNAL, `Failed to start HTTP/2 stream with error: ${error.message}`);\n                }\n              }\n            } else {\n              /* The logic for doing this here is the same as in the catch\n               * block above */\n              this.trace('Picked subchannel ' + pickResult.subchannel.getAddress() + ' has state ' + connectivity_state_1.ConnectivityState[subchannelState] + ' after metadata filters. Retrying pick', constants_1.LogVerbosity.INFO);\n              this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n            }\n          }, error => {\n            // We assume the error code isn't 0 (Status.OK)\n            callStream.cancelWithStatus(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n          });\n        }\n\n        break;\n\n      case picker_1.PickResultType.QUEUE:\n        this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n        break;\n\n      case picker_1.PickResultType.TRANSIENT_FAILURE:\n        if (callMetadata.getOptions().waitForReady) {\n          this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n        } else {\n          callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);\n        }\n\n        break;\n\n      case picker_1.PickResultType.DROP:\n        callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);\n        break;\n\n      default:\n        throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);\n    }\n  }\n\n  removeConnectivityStateWatcher(watcherObject) {\n    const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);\n\n    if (watcherIndex >= 0) {\n      this.connectivityStateWatchers.splice(watcherIndex, 1);\n    }\n  }\n\n  updateState(newState) {\n    logging_1.trace(constants_1.LogVerbosity.DEBUG, 'connectivity_state', '(' + this.channelzRef.id + ') ' + uri_parser_1.uriToString(this.target) + ' ' + connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n\n    this.connectivityState = newState;\n    const watchersCopy = this.connectivityStateWatchers.slice();\n\n    for (const watcherObject of watchersCopy) {\n      if (newState !== watcherObject.currentState) {\n        if (watcherObject.timer) {\n          clearTimeout(watcherObject.timer);\n        }\n\n        this.removeConnectivityStateWatcher(watcherObject);\n        watcherObject.callback();\n      }\n    }\n  }\n\n  tryGetConfig(stream, metadata) {\n    if (stream.getStatus() !== null) {\n      /* If the stream has a status, it has already finished and we don't need\n       * to take any more actions on it. */\n      return;\n    }\n\n    if (this.configSelector === null) {\n      /* This branch will only be taken at the beginning of the channel's life,\n       * before the resolver ever returns a result. So, the\n       * ResolvingLoadBalancer may be idle and if so it needs to be kicked\n       * because it now has a pending request. */\n      this.resolvingLoadBalancer.exitIdle();\n      this.configSelectionQueue.push({\n        callStream: stream,\n        callMetadata: metadata\n      });\n      this.callRefTimerRef();\n    } else {\n      const callConfig = this.configSelector(stream.getMethod(), metadata);\n\n      if (callConfig.status === constants_1.Status.OK) {\n        if (callConfig.methodConfig.timeout) {\n          const deadline = new Date();\n          deadline.setSeconds(deadline.getSeconds() + callConfig.methodConfig.timeout.seconds);\n          deadline.setMilliseconds(deadline.getMilliseconds() + callConfig.methodConfig.timeout.nanos / 1000000);\n          stream.setConfigDeadline(deadline); // Refreshing the filters makes the deadline filter pick up the new deadline\n\n          stream.filterStack.refresh();\n        }\n\n        if (callConfig.dynamicFilterFactories.length > 0) {\n          /* These dynamicFilters are the mechanism for implementing gRFC A39:\n           * https://github.com/grpc/proposal/blob/master/A39-xds-http-filters.md\n           * We run them here instead of with the rest of the filters because\n           * that spec says \"the xDS HTTP filters will run in between name\n           * resolution and load balancing\".\n           *\n           * We use the filter stack here to simplify the multi-filter async\n           * waterfall logic, but we pass along the underlying list of filters\n           * to avoid having nested filter stacks when combining it with the\n           * original filter stack. We do not pass along the original filter\n           * factory list because these filters may need to persist data\n           * between sending headers and other operations. */\n          const dynamicFilterStackFactory = new filter_stack_1.FilterStackFactory(callConfig.dynamicFilterFactories);\n          const dynamicFilterStack = dynamicFilterStackFactory.createFilter(stream);\n          dynamicFilterStack.sendMetadata(Promise.resolve(metadata)).then(filteredMetadata => {\n            this.tryPick(stream, filteredMetadata, callConfig, dynamicFilterStack.getFilters());\n          });\n        } else {\n          this.tryPick(stream, metadata, callConfig, []);\n        }\n      } else {\n        stream.cancelWithStatus(callConfig.status, 'Failed to route call to method ' + stream.getMethod());\n      }\n    }\n  }\n\n  _startCallStream(stream, metadata) {\n    this.tryGetConfig(stream, metadata.clone());\n  }\n\n  close() {\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);\n    clearInterval(this.callRefTimer);\n\n    if (this.channelzEnabled) {\n      channelz_1.unregisterChannelzRef(this.channelzRef);\n    }\n\n    this.subchannelPool.unrefUnusedSubchannels();\n  }\n\n  getTarget() {\n    return uri_parser_1.uriToString(this.target);\n  }\n\n  getConnectivityState(tryToConnect) {\n    const connectivityState = this.connectivityState;\n\n    if (tryToConnect) {\n      this.resolvingLoadBalancer.exitIdle();\n    }\n\n    return connectivityState;\n  }\n\n  watchConnectivityState(currentState, deadline, callback) {\n    if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n\n    let timer = null;\n\n    if (deadline !== Infinity) {\n      const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n      const now = new Date();\n\n      if (deadline === -Infinity || deadlineDate <= now) {\n        process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n        return;\n      }\n\n      timer = setTimeout(() => {\n        this.removeConnectivityStateWatcher(watcherObject);\n        callback(new Error('Deadline passed without connectivity state change'));\n      }, deadlineDate.getTime() - now.getTime());\n    }\n\n    const watcherObject = {\n      currentState,\n      callback,\n      timer\n    };\n    this.connectivityStateWatchers.push(watcherObject);\n  }\n  /**\n   * Get the channelz reference object for this channel. The returned value is\n   * garbage if channelz is disabled for this channel.\n   * @returns\n   */\n\n\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n\n  createCall(method, deadline, host, parentCall, propagateFlags) {\n    if (typeof method !== 'string') {\n      throw new TypeError('Channel#createCall: method must be a string');\n    }\n\n    if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n      throw new TypeError('Channel#createCall: deadline must be a number or Date');\n    }\n\n    if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n\n    const callNumber = getNewCallNumber();\n    this.trace('createCall [' + callNumber + '] method=\"' + method + '\", deadline=' + deadline);\n    const finalOptions = {\n      deadline: deadline,\n      flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n      host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n      parentCall: parentCall\n    };\n    const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);\n\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      stream.addStatusWatcher(status => {\n        if (status.code === constants_1.Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n    }\n\n    return stream;\n  }\n\n}\n\nexports.ChannelImplementation = ChannelImplementation;","map":{"version":3,"mappings":"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","names":["MAX_TIMEOUT_TIME","nextCallNumber","getNewCallNumber","callNumber","Number","MAX_SAFE_INTEGER","ChannelImplementation","constructor","target","credentials","options","connectivity_state_1","IDLE","picker_1","channelz_1","TypeError","channel_credentials_1","originalTarget","originalTargetUri","uri_parser_1","Error","defaultSchemeMapResult","resolver_1","callRefTimer","setInterval","unref","_b","channelzEnabled","channelzTrace","channelzRef","getChannelzInfo","addTrace","kind","id","name","defaultAuthority","proxyMapResult","http_proxy_1","Object","assign","extraOptions","subchannelPool","subchannel_pool_1","_c","channelControlHelper","createSubchannel","subchannelAddress","subchannelArgs","subchannel","getOrCreateSubchannel","getChannelzRef","updateState","connectivityState","picker","currentPicker","queueCopy","pickQueue","slice","callRefTimerUnref","callStream","callMetadata","callConfig","dynamicFilters","tryPick","requestReresolution","addChannelzChild","child","childrenTracker","refChild","removeChannelzChild","unrefChild","resolvingLoadBalancer","resolving_load_balancer_1","configSelector","process","nextTick","localQueue","configSelectionQueue","tryGetConfig","status","code","details","length","trace","getOptions","waitForReady","callRefTimerRef","push","cancelWithStatus","filterStackFactory","filter_stack_1","call_credentials_filter_1","deadline_filter_1","max_message_size_filter_1","compression_filter_1","JSON","stringify","undefined","state","callTracker","children","getChildLists","text","verbosityOverride","logging_1","constants_1","DEBUG","hasRef","ref","_d","pushPick","pickResult","pick","metadata","extraPickInfo","pickInformation","pickResultType","_a","getAddress","COMPLETE","UNAVAILABLE","getConnectivityState","READY","ERROR","filterStack","sendMetadata","Promise","resolve","clone","then","finalMetadata","subchannelState","pickExtraFilters","extraFilterFactories","map","factory","createFilter","startCallStream","onCommitted","onCallStarted","error","message","INFO","INTERNAL","UNKNOWN","QUEUE","TRANSIENT_FAILURE","DROP","removeConnectivityStateWatcher","watcherObject","watcherIndex","connectivityStateWatchers","findIndex","value","splice","newState","watchersCopy","currentState","timer","clearTimeout","callback","stream","getStatus","exitIdle","getMethod","OK","methodConfig","timeout","deadline","Date","setSeconds","getSeconds","seconds","setMilliseconds","getMilliseconds","nanos","setConfigDeadline","refresh","dynamicFilterFactories","dynamicFilterStackFactory","dynamicFilterStack","filteredMetadata","getFilters","_startCallStream","close","destroy","SHUTDOWN","clearInterval","unrefUnusedSubchannels","getTarget","tryToConnect","watchConnectivityState","Infinity","deadlineDate","now","setTimeout","getTime","createCall","method","host","parentCall","propagateFlags","finalOptions","flags","DEFAULTS","call_stream_1","_getCallCredentials","addCallStarted","addStatusWatcher","addCallSucceeded","addCallFailed","exports"],"sources":["/Users/ivica/Desktop/dev/Smart Brain/Frontend/node_modules/@grpc/grpc-js/src/channel.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  Deadline,\n  Call,\n  Http2CallStream,\n  CallStreamOptions,\n} from './call-stream';\nimport { ChannelCredentials } from './channel-credentials';\nimport { ChannelOptions } from './channel-options';\nimport { ResolvingLoadBalancer } from './resolving-load-balancer';\nimport { SubchannelPool, getSubchannelPool } from './subchannel-pool';\nimport { ChannelControlHelper } from './load-balancer';\nimport { UnavailablePicker, Picker, PickResultType } from './picker';\nimport { Metadata } from './metadata';\nimport { Status, LogVerbosity, Propagate } from './constants';\nimport { FilterStackFactory } from './filter-stack';\nimport { CallCredentialsFilterFactory } from './call-credentials-filter';\nimport { DeadlineFilterFactory } from './deadline-filter';\nimport { CompressionFilterFactory } from './compression-filter';\nimport {\n  CallConfig,\n  ConfigSelector,\n  getDefaultAuthority,\n  mapUriDefaultScheme,\n} from './resolver';\nimport { trace, log } from './logging';\nimport { SubchannelAddress } from './subchannel-address';\nimport { MaxMessageSizeFilterFactory } from './max-message-size-filter';\nimport { mapProxyName } from './http_proxy';\nimport { GrpcUri, parseUri, uriToString } from './uri-parser';\nimport { ServerSurfaceCall } from './server-call';\nimport { Filter } from './filter';\n\nimport { ConnectivityState } from './connectivity-state';\nimport { ChannelInfo, ChannelRef, ChannelzCallTracker, ChannelzChildrenTracker, ChannelzTrace, registerChannelzChannel, SubchannelRef, unregisterChannelzRef } from './channelz';\n\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\n\nlet nextCallNumber = 0;\n\nfunction getNewCallNumber(): number {\n  const callNumber = nextCallNumber;\n  nextCallNumber += 1;\n  if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n    nextCallNumber = 0;\n  }\n  return callNumber;\n}\n\n/**\n * An interface that represents a communication channel to a server specified\n * by a given address.\n */\nexport interface Channel {\n  /**\n   * Close the channel. This has the same functionality as the existing\n   * grpc.Client.prototype.close\n   */\n  close(): void;\n  /**\n   * Return the target that this channel connects to\n   */\n  getTarget(): string;\n  /**\n   * Get the channel's current connectivity state. This method is here mainly\n   * because it is in the existing internal Channel class, and there isn't\n   * another good place to put it.\n   * @param tryToConnect If true, the channel will start connecting if it is\n   *     idle. Otherwise, idle channels will only start connecting when a\n   *     call starts.\n   */\n  getConnectivityState(tryToConnect: boolean): ConnectivityState;\n  /**\n   * Watch for connectivity state changes. This is also here mainly because\n   * it is in the existing external Channel class.\n   * @param currentState The state to watch for transitions from. This should\n   *     always be populated by calling getConnectivityState immediately\n   *     before.\n   * @param deadline A deadline for waiting for a state change\n   * @param callback Called with no error when a state change, or with an\n   *     error if the deadline passes without a state change.\n   */\n  watchConnectivityState(\n    currentState: ConnectivityState,\n    deadline: Date | number,\n    callback: (error?: Error) => void\n  ): void;\n  /**\n   * Get the channelz reference object for this channel. A request to the\n   * channelz service for the id in this object will provide information\n   * about this channel.\n   */\n  getChannelzRef(): ChannelRef;\n  /**\n   * Create a call object. Call is an opaque type that is used by the Client\n   * class. This function is called by the gRPC library when starting a\n   * request. Implementers should return an instance of Call that is returned\n   * from calling createCall on an instance of the provided Channel class.\n   * @param method The full method string to request.\n   * @param deadline The call deadline\n   * @param host A host string override for making the request\n   * @param parentCall A server call to propagate some information from\n   * @param propagateFlags A bitwise combination of elements of grpc.propagate\n   *     that indicates what information to propagate from parentCall.\n   */\n  createCall(\n    method: string,\n    deadline: Deadline,\n    host: string | null | undefined,\n    parentCall: ServerSurfaceCall | null,\n    propagateFlags: number | null | undefined\n  ): Call;\n}\n\ninterface ConnectivityStateWatcher {\n  currentState: ConnectivityState;\n  timer: NodeJS.Timeout | null;\n  callback: (error?: Error) => void;\n}\n\nexport class ChannelImplementation implements Channel {\n  private resolvingLoadBalancer: ResolvingLoadBalancer;\n  private subchannelPool: SubchannelPool;\n  private connectivityState: ConnectivityState = ConnectivityState.IDLE;\n  private currentPicker: Picker = new UnavailablePicker();\n  /**\n   * Calls queued up to get a call config. Should only be populated before the\n   * first time the resolver returns a result, which includes the ConfigSelector.\n   */\n  private configSelectionQueue: Array<{\n    callStream: Http2CallStream;\n    callMetadata: Metadata;\n  }> = [];\n  private pickQueue: Array<{\n    callStream: Http2CallStream;\n    callMetadata: Metadata;\n    callConfig: CallConfig;\n    dynamicFilters: Filter[];\n  }> = [];\n  private connectivityStateWatchers: ConnectivityStateWatcher[] = [];\n  private defaultAuthority: string;\n  private filterStackFactory: FilterStackFactory;\n  private target: GrpcUri;\n  /**\n   * This timer does not do anything on its own. Its purpose is to hold the\n   * event loop open while there are any pending calls for the channel that\n   * have not yet been assigned to specific subchannels. In other words,\n   * the invariant is that callRefTimer is reffed if and only if pickQueue\n   * is non-empty.\n   */\n  private callRefTimer: NodeJS.Timer;\n  private configSelector: ConfigSelector | null = null;\n\n  // Channelz info\n  private readonly channelzEnabled: boolean = true;\n  private originalTarget: string;\n  private channelzRef: ChannelRef;\n  private channelzTrace: ChannelzTrace;\n  private callTracker = new ChannelzCallTracker();\n  private childrenTracker = new ChannelzChildrenTracker();\n\n  constructor(\n    target: string,\n    private readonly credentials: ChannelCredentials,\n    private readonly options: ChannelOptions\n  ) {\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n    if (!(credentials instanceof ChannelCredentials)) {\n      throw new TypeError(\n        'Channel credentials must be a ChannelCredentials object'\n      );\n    }\n    if (options) {\n      if (typeof options !== 'object') {\n        throw new TypeError('Channel options must be an object');\n      }\n    }\n    this.originalTarget = target;\n    const originalTargetUri = parseUri(target);\n    if (originalTargetUri === null) {\n      throw new Error(`Could not parse target name \"${target}\"`);\n    }\n    /* This ensures that the target has a scheme that is registered with the\n     * resolver */\n    const defaultSchemeMapResult = mapUriDefaultScheme(originalTargetUri);\n    if (defaultSchemeMapResult === null) {\n      throw new Error(\n        `Could not find a default scheme for target name \"${target}\"`\n      );\n    }\n\n    this.callRefTimer = setInterval(() => {}, MAX_TIMEOUT_TIME);\n    this.callRefTimer.unref?.();\n\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n\n    this.channelzTrace = new ChannelzTrace();\n    if (this.channelzEnabled) {\n      this.channelzRef = registerChannelzChannel(target, () => this.getChannelzInfo());\n      this.channelzTrace.addTrace('CT_INFO', 'Channel created');\n    } else {\n      // Dummy channelz ref that will never be used\n      this.channelzRef = {\n        kind: 'channel',\n        id: -1,\n        name: ''\n      };\n    }\n\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'] as string;\n    } else {\n      this.defaultAuthority = getDefaultAuthority(defaultSchemeMapResult);\n    }\n    const proxyMapResult = mapProxyName(defaultSchemeMapResult, options);\n    this.target = proxyMapResult.target;\n    this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n\n    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n     * the grpc.use_local_subchannel_pool channel option means. */\n    this.subchannelPool = getSubchannelPool(\n      (options['grpc.use_local_subchannel_pool'] ?? 0) === 0\n    );\n    const channelControlHelper: ChannelControlHelper = {\n      createSubchannel: (\n        subchannelAddress: SubchannelAddress,\n        subchannelArgs: ChannelOptions\n      ) => {\n        const subchannel = this.subchannelPool.getOrCreateSubchannel(\n          this.target,\n          subchannelAddress,\n          Object.assign({}, this.options, subchannelArgs),\n          this.credentials\n        );\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());\n        }\n        return subchannel;\n      },\n      updateState: (connectivityState: ConnectivityState, picker: Picker) => {\n        this.currentPicker = picker;\n        const queueCopy = this.pickQueue.slice();\n        this.pickQueue = [];\n        this.callRefTimerUnref();\n        for (const { callStream, callMetadata, callConfig, dynamicFilters } of queueCopy) {\n          this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n        }\n        this.updateState(connectivityState);\n      },\n      requestReresolution: () => {\n        // This should never be called.\n        throw new Error(\n          'Resolving load balancer should never call requestReresolution'\n        );\n      },\n      addChannelzChild: (child: ChannelRef | SubchannelRef) => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.refChild(child);\n        }\n      },\n      removeChannelzChild: (child: ChannelRef | SubchannelRef) => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.unrefChild(child);\n        }\n      }\n    };\n    this.resolvingLoadBalancer = new ResolvingLoadBalancer(\n      this.target,\n      channelControlHelper,\n      options,\n      (configSelector) => {\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');\n        }\n        this.configSelector = configSelector;\n        /* We process the queue asynchronously to ensure that the corresponding\n         * load balancer update has completed. */\n        process.nextTick(() => {\n          const localQueue = this.configSelectionQueue;\n          this.configSelectionQueue = [];\n          this.callRefTimerUnref();\n          for (const { callStream, callMetadata } of localQueue) {\n            this.tryGetConfig(callStream, callMetadata);\n          }\n          this.configSelectionQueue = [];\n        });\n      },\n      (status) => {\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' + status.code + ' and details \"' + status.details + '\"');\n        }\n        if (this.configSelectionQueue.length > 0) {\n          this.trace('Name resolution failed with calls queued for config selection');\n        }\n        const localQueue = this.configSelectionQueue;\n        this.configSelectionQueue = [];\n        this.callRefTimerUnref();\n        for (const { callStream, callMetadata } of localQueue) {\n          if (callMetadata.getOptions().waitForReady) {\n            this.callRefTimerRef();\n            this.configSelectionQueue.push({ callStream, callMetadata });\n          } else {\n            callStream.cancelWithStatus(status.code, status.details);\n          }\n        }\n      }\n    );\n    this.filterStackFactory = new FilterStackFactory([\n      new CallCredentialsFilterFactory(this),\n      new DeadlineFilterFactory(this),\n      new MaxMessageSizeFilterFactory(this.options),\n      new CompressionFilterFactory(this, this.options),\n    ]);\n    this.trace('Channel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n\n  private getChannelzInfo(): ChannelInfo {\n    return {\n      target: this.originalTarget,\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists()\n    };\n  }\n\n  private trace(text: string, verbosityOverride?: LogVerbosity) {\n    trace(verbosityOverride ?? LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + uriToString(this.target) + ' ' + text);\n  }\n\n  private callRefTimerRef() {\n    // If the hasRef function does not exist, always run the code\n    if (!this.callRefTimer.hasRef?.()) {\n      this.trace(\n        'callRefTimer.ref | configSelectionQueue.length=' +\n          this.configSelectionQueue.length +\n          ' pickQueue.length=' +\n          this.pickQueue.length\n      );\n      this.callRefTimer.ref?.();\n    }\n  }\n\n  private callRefTimerUnref() {\n    // If the hasRef function does not exist, always run the code\n    if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n      this.trace(\n        'callRefTimer.unref | configSelectionQueue.length=' +\n          this.configSelectionQueue.length +\n          ' pickQueue.length=' +\n          this.pickQueue.length\n      );\n      this.callRefTimer.unref?.();\n    }\n  }\n\n  private pushPick(\n    callStream: Http2CallStream,\n    callMetadata: Metadata,\n    callConfig: CallConfig,\n    dynamicFilters: Filter[]\n  ) {\n    this.pickQueue.push({ callStream, callMetadata, callConfig, dynamicFilters });\n    this.callRefTimerRef();\n  }\n\n  /**\n   * Check the picker output for the given call and corresponding metadata,\n   * and take any relevant actions. Should not be called while iterating\n   * over pickQueue.\n   * @param callStream\n   * @param callMetadata\n   */\n  private tryPick(\n    callStream: Http2CallStream,\n    callMetadata: Metadata,\n    callConfig: CallConfig,\n    dynamicFilters: Filter[]\n  ) {\n    const pickResult = this.currentPicker.pick({\n      metadata: callMetadata,\n      extraPickInfo: callConfig.pickInformation,\n    });\n    this.trace(\n      'Pick result: ' +\n        PickResultType[pickResult.pickResultType] +\n        ' subchannel: ' +\n        pickResult.subchannel?.getAddress() +\n        ' status: ' +\n        pickResult.status?.code +\n        ' ' +\n        pickResult.status?.details\n    );\n    switch (pickResult.pickResultType) {\n      case PickResultType.COMPLETE:\n        if (pickResult.subchannel === null) {\n          callStream.cancelWithStatus(\n            Status.UNAVAILABLE,\n            'Request dropped by load balancing policy'\n          );\n          // End the call with an error\n        } else {\n          /* If the subchannel is not in the READY state, that indicates a bug\n           * somewhere in the load balancer or picker. So, we log an error and\n           * queue the pick to be tried again later. */\n          if (\n            pickResult.subchannel!.getConnectivityState() !==\n            ConnectivityState.READY\n          ) {\n            log(\n              LogVerbosity.ERROR,\n              'Error: COMPLETE pick result subchannel ' +\n                pickResult.subchannel!.getAddress() +\n                ' has state ' +\n                ConnectivityState[pickResult.subchannel!.getConnectivityState()]\n            );\n            this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n            break;\n          }\n          /* We need to clone the callMetadata here because the transparent\n           * retry code in the promise resolution handler use the same\n           * callMetadata object, so it needs to stay unmodified */\n          callStream.filterStack\n            .sendMetadata(Promise.resolve(callMetadata.clone()))\n            .then(\n              (finalMetadata) => {\n                const subchannelState: ConnectivityState = pickResult.subchannel!.getConnectivityState();\n                if (subchannelState === ConnectivityState.READY) {\n                  try {\n                    const pickExtraFilters = pickResult.extraFilterFactories.map(factory => factory.createFilter(callStream));\n                    pickResult.subchannel!.startCallStream(\n                      finalMetadata,\n                      callStream,\n                      [...dynamicFilters, ...pickExtraFilters]\n                    );\n                    /* If we reach this point, the call stream has started\n                     * successfully */\n                    callConfig.onCommitted?.();\n                    pickResult.onCallStarted?.();\n                  } catch (error) {\n                    if (\n                      (error as NodeJS.ErrnoException).code ===\n                      'ERR_HTTP2_GOAWAY_SESSION'\n                    ) {\n                      /* An error here indicates that something went wrong with\n                       * the picked subchannel's http2 stream right before we\n                       * tried to start the stream. We are handling a promise\n                       * result here, so this is asynchronous with respect to the\n                       * original tryPick call, so calling it again is not\n                       * recursive. We call tryPick immediately instead of\n                       * queueing this pick again because handling the queue is\n                       * triggered by state changes, and we want to immediately\n                       * check if the state has already changed since the\n                       * previous tryPick call. We do this instead of cancelling\n                       * the stream because the correct behavior may be\n                       * re-queueing instead, based on the logic in the rest of\n                       * tryPick */\n                      this.trace(\n                        'Failed to start call on picked subchannel ' +\n                          pickResult.subchannel!.getAddress() +\n                          ' with error ' +\n                          (error as Error).message +\n                          '. Retrying pick',\n                          LogVerbosity.INFO\n                      );\n                      this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                    } else {\n                      this.trace(\n                        'Failed to start call on picked subchanel ' +\n                          pickResult.subchannel!.getAddress() +\n                          ' with error ' +\n                          (error as Error).message +\n                          '. Ending call',\n                          LogVerbosity.INFO\n                      );\n                      callStream.cancelWithStatus(\n                        Status.INTERNAL,\n                        `Failed to start HTTP/2 stream with error: ${\n                          (error as Error).message\n                        }`\n                      );\n                    }\n                  }\n                } else {\n                  /* The logic for doing this here is the same as in the catch\n                   * block above */\n                  this.trace(\n                    'Picked subchannel ' +\n                      pickResult.subchannel!.getAddress() +\n                      ' has state ' +\n                      ConnectivityState[subchannelState] +\n                      ' after metadata filters. Retrying pick',\n                      LogVerbosity.INFO\n                  );\n                  this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                }\n              },\n              (error: Error & { code: number }) => {\n                // We assume the error code isn't 0 (Status.OK)\n                callStream.cancelWithStatus(\n                  typeof error.code === 'number' ? error.code : Status.UNKNOWN,\n                  `Getting metadata from plugin failed with error: ${error.message}`\n                );\n              }\n            );\n        }\n        break;\n      case PickResultType.QUEUE:\n        this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n        break;\n      case PickResultType.TRANSIENT_FAILURE:\n        if (callMetadata.getOptions().waitForReady) {\n          this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n        } else {\n          callStream.cancelWithStatus(\n            pickResult.status!.code,\n            pickResult.status!.details\n          );\n        }\n        break;\n      case PickResultType.DROP:\n        callStream.cancelWithStatus(\n          pickResult.status!.code,\n          pickResult.status!.details\n        );\n        break;\n      default:\n        throw new Error(\n          `Invalid state: unknown pickResultType ${pickResult.pickResultType}`\n        );\n    }\n  }\n\n  private removeConnectivityStateWatcher(\n    watcherObject: ConnectivityStateWatcher\n  ) {\n    const watcherIndex = this.connectivityStateWatchers.findIndex(\n      (value) => value === watcherObject\n    );\n    if (watcherIndex >= 0) {\n      this.connectivityStateWatchers.splice(watcherIndex, 1);\n    }\n  }\n\n  private updateState(newState: ConnectivityState): void {\n    trace(\n      LogVerbosity.DEBUG,\n      'connectivity_state',\n      '(' + this.channelzRef.id + ') ' + \n        uriToString(this.target) +\n        ' ' +\n        ConnectivityState[this.connectivityState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', ConnectivityState[this.connectivityState] + ' -> ' + ConnectivityState[newState]);\n    }\n    this.connectivityState = newState;\n    const watchersCopy = this.connectivityStateWatchers.slice();\n    for (const watcherObject of watchersCopy) {\n      if (newState !== watcherObject.currentState) {\n        if (watcherObject.timer) {\n          clearTimeout(watcherObject.timer);\n        }\n        this.removeConnectivityStateWatcher(watcherObject);\n        watcherObject.callback();\n      }\n    }\n  }\n\n  private tryGetConfig(stream: Http2CallStream, metadata: Metadata) {\n    if (stream.getStatus() !== null) {\n      /* If the stream has a status, it has already finished and we don't need\n       * to take any more actions on it. */\n      return;\n    }\n    if (this.configSelector === null) {\n      /* This branch will only be taken at the beginning of the channel's life,\n       * before the resolver ever returns a result. So, the\n       * ResolvingLoadBalancer may be idle and if so it needs to be kicked\n       * because it now has a pending request. */\n      this.resolvingLoadBalancer.exitIdle();\n      this.configSelectionQueue.push({\n        callStream: stream,\n        callMetadata: metadata,\n      });\n      this.callRefTimerRef();\n    } else {\n      const callConfig = this.configSelector(stream.getMethod(), metadata);\n      if (callConfig.status === Status.OK) {\n        if (callConfig.methodConfig.timeout) {\n          const deadline = new Date();\n          deadline.setSeconds(\n            deadline.getSeconds() + callConfig.methodConfig.timeout.seconds\n          );\n          deadline.setMilliseconds(\n            deadline.getMilliseconds() +\n              callConfig.methodConfig.timeout.nanos / 1_000_000\n          );\n          stream.setConfigDeadline(deadline);\n          // Refreshing the filters makes the deadline filter pick up the new deadline\n          stream.filterStack.refresh();\n        }\n        if (callConfig.dynamicFilterFactories.length > 0) {\n          /* These dynamicFilters are the mechanism for implementing gRFC A39:\n           * https://github.com/grpc/proposal/blob/master/A39-xds-http-filters.md\n           * We run them here instead of with the rest of the filters because\n           * that spec says \"the xDS HTTP filters will run in between name \n           * resolution and load balancing\".\n           * \n           * We use the filter stack here to simplify the multi-filter async\n           * waterfall logic, but we pass along the underlying list of filters\n           * to avoid having nested filter stacks when combining it with the\n           * original filter stack. We do not pass along the original filter\n           * factory list because these filters may need to persist data\n           * between sending headers and other operations. */\n          const dynamicFilterStackFactory = new FilterStackFactory(callConfig.dynamicFilterFactories);\n          const dynamicFilterStack = dynamicFilterStackFactory.createFilter(stream);\n          dynamicFilterStack.sendMetadata(Promise.resolve(metadata)).then(filteredMetadata => {\n            this.tryPick(stream, filteredMetadata, callConfig, dynamicFilterStack.getFilters());\n          });\n        } else {\n          this.tryPick(stream, metadata, callConfig, []);\n        }\n      } else {\n        stream.cancelWithStatus(\n          callConfig.status,\n          'Failed to route call to method ' + stream.getMethod()\n        );\n      }\n    }\n  }\n\n  _startCallStream(stream: Http2CallStream, metadata: Metadata) {\n    this.tryGetConfig(stream, metadata.clone());\n  }\n\n  close() {\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(ConnectivityState.SHUTDOWN);\n    clearInterval(this.callRefTimer);\n    if (this.channelzEnabled) {\n      unregisterChannelzRef(this.channelzRef);\n    }\n\n    this.subchannelPool.unrefUnusedSubchannels();\n  }\n\n  getTarget() {\n    return uriToString(this.target);\n  }\n\n  getConnectivityState(tryToConnect: boolean) {\n    const connectivityState = this.connectivityState;\n    if (tryToConnect) {\n      this.resolvingLoadBalancer.exitIdle();\n    }\n    return connectivityState;\n  }\n\n  watchConnectivityState(\n    currentState: ConnectivityState,\n    deadline: Date | number,\n    callback: (error?: Error) => void\n  ): void {\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    let timer = null;\n    if (deadline !== Infinity) {\n      const deadlineDate: Date =\n        deadline instanceof Date ? deadline : new Date(deadline);\n      const now = new Date();\n      if (deadline === -Infinity || deadlineDate <= now) {\n        process.nextTick(\n          callback,\n          new Error('Deadline passed without connectivity state change')\n        );\n        return;\n      }\n      timer = setTimeout(() => {\n        this.removeConnectivityStateWatcher(watcherObject);\n        callback(\n          new Error('Deadline passed without connectivity state change')\n        );\n      }, deadlineDate.getTime() - now.getTime());\n    }\n    const watcherObject = {\n      currentState,\n      callback,\n      timer,\n    };\n    this.connectivityStateWatchers.push(watcherObject);\n  }\n\n  /**\n   * Get the channelz reference object for this channel. The returned value is\n   * garbage if channelz is disabled for this channel.\n   * @returns \n   */\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n\n  createCall(\n    method: string,\n    deadline: Deadline,\n    host: string | null | undefined,\n    parentCall: ServerSurfaceCall | null,\n    propagateFlags: number | null | undefined\n  ): Call {\n    if (typeof method !== 'string') {\n      throw new TypeError('Channel#createCall: method must be a string');\n    }\n    if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n      throw new TypeError(\n        'Channel#createCall: deadline must be a number or Date'\n      );\n    }\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    const callNumber = getNewCallNumber();\n    this.trace(\n      'createCall [' +\n        callNumber +\n        '] method=\"' +\n        method +\n        '\", deadline=' +\n        deadline\n    );\n    const finalOptions: CallStreamOptions = {\n      deadline: deadline,\n      flags: propagateFlags ?? Propagate.DEFAULTS,\n      host: host ?? this.defaultAuthority,\n      parentCall: parentCall,\n    };\n    const stream: Http2CallStream = new Http2CallStream(\n      method,\n      this,\n      finalOptions,\n      this.filterStackFactory,\n      this.credentials._getCallCredentials(),\n      callNumber\n    );\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      stream.addStatusWatcher(status => {\n        if (status.code === Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n    }\n    return stream;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}