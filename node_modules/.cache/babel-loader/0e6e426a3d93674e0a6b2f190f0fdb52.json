{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChannelCredentials = void 0;\n\nconst tls_1 = require(\"tls\");\n\nconst call_credentials_1 = require(\"./call-credentials\");\n\nconst tls_helpers_1 = require(\"./tls-helpers\"); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction verifyIsBufferOrNull(obj, friendlyName) {\n  if (obj && !(obj instanceof Buffer)) {\n    throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\n  }\n}\n\nfunction bufferOrNullEqual(buf1, buf2) {\n  if (buf1 === null && buf2 === null) {\n    return true;\n  } else {\n    return buf1 !== null && buf2 !== null && buf1.equals(buf2);\n  }\n}\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */\n\n\nclass ChannelCredentials {\n  constructor(callCredentials) {\n    this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();\n  }\n  /**\n   * Gets the set of per-call credentials associated with this instance.\n   */\n\n\n  _getCallCredentials() {\n    return this.callCredentials;\n  }\n  /**\n   * Return a new ChannelCredentials instance with a given set of credentials.\n   * The resulting instance can be used to construct a Channel that communicates\n   * over TLS.\n   * @param rootCerts The root certificate data.\n   * @param privateKey The client certificate private key, if available.\n   * @param certChain The client certificate key chain, if available.\n   */\n\n\n  static createSsl(rootCerts, privateKey, certChain, verifyOptions) {\n    verifyIsBufferOrNull(rootCerts, 'Root certificate');\n    verifyIsBufferOrNull(privateKey, 'Private key');\n    verifyIsBufferOrNull(certChain, 'Certificate chain');\n\n    if (privateKey && !certChain) {\n      throw new Error('Private key must be given with accompanying certificate chain');\n    }\n\n    if (!privateKey && certChain) {\n      throw new Error('Certificate chain must be given with accompanying private key');\n    }\n\n    return new SecureChannelCredentialsImpl(rootCerts || tls_helpers_1.getDefaultRootsData(), privateKey || null, certChain || null, verifyOptions || {});\n  }\n  /**\n   * Return a new ChannelCredentials instance with no credentials.\n   */\n\n\n  static createInsecure() {\n    return new InsecureChannelCredentialsImpl();\n  }\n\n}\n\nexports.ChannelCredentials = ChannelCredentials;\n\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n  constructor(callCredentials) {\n    super(callCredentials);\n  }\n\n  compose(callCredentials) {\n    throw new Error('Cannot compose insecure credentials');\n  }\n\n  _getConnectionOptions() {\n    return null;\n  }\n\n  _isSecure() {\n    return false;\n  }\n\n  _equals(other) {\n    return other instanceof InsecureChannelCredentialsImpl;\n  }\n\n}\n\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n  constructor(rootCerts, privateKey, certChain, verifyOptions) {\n    super();\n    this.rootCerts = rootCerts;\n    this.privateKey = privateKey;\n    this.certChain = certChain;\n    this.verifyOptions = verifyOptions;\n    const secureContext = tls_1.createSecureContext({\n      ca: rootCerts || undefined,\n      key: privateKey || undefined,\n      cert: certChain || undefined,\n      ciphers: tls_helpers_1.CIPHER_SUITES\n    });\n    this.connectionOptions = {\n      secureContext\n    }; // Node asserts that this option is a function, so we cannot pass undefined\n\n    if (verifyOptions === null || verifyOptions === void 0 ? void 0 : verifyOptions.checkServerIdentity) {\n      this.connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;\n    }\n  }\n\n  compose(callCredentials) {\n    const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n    return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);\n  }\n\n  _getConnectionOptions() {\n    // Copy to prevent callers from mutating this.connectionOptions\n    return Object.assign({}, this.connectionOptions);\n  }\n\n  _isSecure() {\n    return true;\n  }\n\n  _equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof SecureChannelCredentialsImpl) {\n      if (!bufferOrNullEqual(this.rootCerts, other.rootCerts)) {\n        return false;\n      }\n\n      if (!bufferOrNullEqual(this.privateKey, other.privateKey)) {\n        return false;\n      }\n\n      if (!bufferOrNullEqual(this.certChain, other.certChain)) {\n        return false;\n      }\n\n      return this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity;\n    } else {\n      return false;\n    }\n  }\n\n}\n\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\n  constructor(channelCredentials, callCreds) {\n    super(callCreds);\n    this.channelCredentials = channelCredentials;\n  }\n\n  compose(callCredentials) {\n    const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n    return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);\n  }\n\n  _getConnectionOptions() {\n    return this.channelCredentials._getConnectionOptions();\n  }\n\n  _isSecure() {\n    return true;\n  }\n\n  _equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof ComposedChannelCredentialsImpl) {\n      return this.channelCredentials._equals(other.channelCredentials) && this.callCredentials._equals(other.callCredentials);\n    } else {\n      return false;\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["verifyIsBufferOrNull","obj","friendlyName","Buffer","TypeError","bufferOrNullEqual","buf1","buf2","equals","ChannelCredentials","constructor","callCredentials","call_credentials_1","createEmpty","_getCallCredentials","createSsl","rootCerts","privateKey","certChain","verifyOptions","Error","SecureChannelCredentialsImpl","tls_helpers_1","createInsecure","InsecureChannelCredentialsImpl","exports","compose","_getConnectionOptions","_isSecure","_equals","other","secureContext","tls_1","ca","undefined","key","cert","ciphers","connectionOptions","checkServerIdentity","combinedCallCredentials","ComposedChannelCredentialsImpl","channelCredentials","callCreds"],"sources":["/Users/ivica/Desktop/dev/face-rec/node_modules/@grpc/grpc-js/src/channel-credentials.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ConnectionOptions, createSecureContext, PeerCertificate } from 'tls';\n\nimport { CallCredentials } from './call-credentials';\nimport { CIPHER_SUITES, getDefaultRootsData } from './tls-helpers';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction verifyIsBufferOrNull(obj: any, friendlyName: string): void {\n  if (obj && !(obj instanceof Buffer)) {\n    throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\n  }\n}\n\n/**\n * A callback that will receive the expected hostname and presented peer\n * certificate as parameters. The callback should return an error to\n * indicate that the presented certificate is considered invalid and\n * otherwise returned undefined.\n */\nexport type CheckServerIdentityCallback = (\n  hostname: string,\n  cert: PeerCertificate\n) => Error | undefined;\n\nfunction bufferOrNullEqual(buf1: Buffer | null, buf2: Buffer | null) {\n  if (buf1 === null && buf2 === null) {\n    return true;\n  } else {\n    return buf1 !== null && buf2 !== null && buf1.equals(buf2);\n  }\n}\n\n/**\n * Additional peer verification options that can be set when creating\n * SSL credentials.\n */\nexport interface VerifyOptions {\n  /**\n   * If set, this callback will be invoked after the usual hostname verification\n   * has been performed on the peer certificate.\n   */\n  checkServerIdentity?: CheckServerIdentityCallback;\n}\n\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */\nexport abstract class ChannelCredentials {\n  protected callCredentials: CallCredentials;\n\n  protected constructor(callCredentials?: CallCredentials) {\n    this.callCredentials = callCredentials || CallCredentials.createEmpty();\n  }\n  /**\n   * Returns a copy of this object with the included set of per-call credentials\n   * expanded to include callCredentials.\n   * @param callCredentials A CallCredentials object to associate with this\n   * instance.\n   */\n  abstract compose(callCredentials: CallCredentials): ChannelCredentials;\n\n  /**\n   * Gets the set of per-call credentials associated with this instance.\n   */\n  _getCallCredentials(): CallCredentials {\n    return this.callCredentials;\n  }\n\n  /**\n   * Gets a SecureContext object generated from input parameters if this\n   * instance was created with createSsl, or null if this instance was created\n   * with createInsecure.\n   */\n  abstract _getConnectionOptions(): ConnectionOptions | null;\n\n  /**\n   * Indicates whether this credentials object creates a secure channel.\n   */\n  abstract _isSecure(): boolean;\n\n  /**\n   * Check whether two channel credentials objects are equal. Two secure\n   * credentials are equal if they were constructed with the same parameters.\n   * @param other The other ChannelCredentials Object\n   */\n  abstract _equals(other: ChannelCredentials): boolean;\n\n  /**\n   * Return a new ChannelCredentials instance with a given set of credentials.\n   * The resulting instance can be used to construct a Channel that communicates\n   * over TLS.\n   * @param rootCerts The root certificate data.\n   * @param privateKey The client certificate private key, if available.\n   * @param certChain The client certificate key chain, if available.\n   */\n  static createSsl(\n    rootCerts?: Buffer | null,\n    privateKey?: Buffer | null,\n    certChain?: Buffer | null,\n    verifyOptions?: VerifyOptions\n  ): ChannelCredentials {\n    verifyIsBufferOrNull(rootCerts, 'Root certificate');\n    verifyIsBufferOrNull(privateKey, 'Private key');\n    verifyIsBufferOrNull(certChain, 'Certificate chain');\n    if (privateKey && !certChain) {\n      throw new Error(\n        'Private key must be given with accompanying certificate chain'\n      );\n    }\n    if (!privateKey && certChain) {\n      throw new Error(\n        'Certificate chain must be given with accompanying private key'\n      );\n    }\n    return new SecureChannelCredentialsImpl(\n      rootCerts || getDefaultRootsData(),\n      privateKey || null,\n      certChain || null,\n      verifyOptions || {}\n    );\n  }\n\n  /**\n   * Return a new ChannelCredentials instance with no credentials.\n   */\n  static createInsecure(): ChannelCredentials {\n    return new InsecureChannelCredentialsImpl();\n  }\n}\n\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n  constructor(callCredentials?: CallCredentials) {\n    super(callCredentials);\n  }\n\n  compose(callCredentials: CallCredentials): ChannelCredentials {\n    throw new Error('Cannot compose insecure credentials');\n  }\n\n  _getConnectionOptions(): ConnectionOptions | null {\n    return null;\n  }\n  _isSecure(): boolean {\n    return false;\n  }\n  _equals(other: ChannelCredentials): boolean {\n    return other instanceof InsecureChannelCredentialsImpl;\n  }\n}\n\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n  connectionOptions: ConnectionOptions;\n\n  constructor(\n    private rootCerts: Buffer | null,\n    private privateKey: Buffer | null,\n    private certChain: Buffer | null,\n    private verifyOptions: VerifyOptions\n  ) {\n    super();\n    const secureContext = createSecureContext({\n      ca: rootCerts || undefined,\n      key: privateKey || undefined,\n      cert: certChain || undefined,\n      ciphers: CIPHER_SUITES,\n    });\n    this.connectionOptions = { \n      secureContext\n    };\n    // Node asserts that this option is a function, so we cannot pass undefined\n    if (verifyOptions?.checkServerIdentity) {\n      this.connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;\n    }\n  }\n\n  compose(callCredentials: CallCredentials): ChannelCredentials {\n    const combinedCallCredentials = this.callCredentials.compose(\n      callCredentials\n    );\n    return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);\n  }\n\n  _getConnectionOptions(): ConnectionOptions | null {\n    // Copy to prevent callers from mutating this.connectionOptions\n    return { ...this.connectionOptions };\n  }\n  _isSecure(): boolean {\n    return true;\n  }\n  _equals(other: ChannelCredentials): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof SecureChannelCredentialsImpl) {\n      if (!bufferOrNullEqual(this.rootCerts, other.rootCerts)) {\n        return false;\n      }\n      if (!bufferOrNullEqual(this.privateKey, other.privateKey)) {\n        return false;\n      }\n      if (!bufferOrNullEqual(this.certChain, other.certChain)) {\n        return false;\n      }\n      return (\n        this.verifyOptions.checkServerIdentity ===\n        other.verifyOptions.checkServerIdentity\n      );\n    } else {\n      return false;\n    }\n  }\n}\n\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\n  constructor(\n    private channelCredentials: SecureChannelCredentialsImpl,\n    callCreds: CallCredentials\n  ) {\n    super(callCreds);\n  }\n  compose(callCredentials: CallCredentials) {\n    const combinedCallCredentials = this.callCredentials.compose(\n      callCredentials\n    );\n    return new ComposedChannelCredentialsImpl(\n      this.channelCredentials,\n      combinedCallCredentials\n    );\n  }\n\n  _getConnectionOptions(): ConnectionOptions | null {\n    return this.channelCredentials._getConnectionOptions();\n  }\n  _isSecure(): boolean {\n    return true;\n  }\n  _equals(other: ChannelCredentials): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof ComposedChannelCredentialsImpl) {\n      return (\n        this.channelCredentials._equals(other.channelCredentials) &&\n        this.callCredentials._equals(other.callCredentials)\n      );\n    } else {\n      return false;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}