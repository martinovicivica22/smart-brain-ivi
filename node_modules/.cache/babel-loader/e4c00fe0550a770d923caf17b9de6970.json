{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = void 0;\n\nconst resolver_1 = require(\"./resolver\");\n\nconst dns = require(\"dns\");\n\nconst util = require(\"util\");\n\nconst service_config_1 = require(\"./service-config\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst logging = require(\"./logging\");\n\nconst constants_2 = require(\"./constants\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nconst net_1 = require(\"net\");\n\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\n\nconst TRACER_NAME = 'dns_resolver';\n\nfunction trace(text) {\n  logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\n\n\nconst DEFAULT_PORT = 443;\nconst resolveTxtPromise = util.promisify(dns.resolveTxt);\nconst dnsLookupPromise = util.promisify(dns.lookup);\n/**\n * Merge any number of arrays into a single alternating array\n * @param arrays\n */\n\nfunction mergeArrays() {\n  const result = [];\n\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n\n  for (let i = 0; i < Math.max.apply(null, arrays.map(array => array.length)); i++) {\n    for (const array of arrays) {\n      if (i < array.length) {\n        result.push(array[i]);\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */\n\n\nclass DnsResolver {\n  constructor(target, listener, channelOptions) {\n    var _a, _b;\n\n    this.target = target;\n    this.listener = listener;\n    this.pendingLookupPromise = null;\n    this.pendingTxtPromise = null;\n    this.latestLookupResult = null;\n    this.latestServiceConfig = null;\n    this.latestServiceConfigError = null;\n    this.continueResolving = false;\n    trace('Resolver constructed for target ' + uri_parser_1.uriToString(target));\n    const hostPort = uri_parser_1.splitHostPort(target.path);\n\n    if (hostPort === null) {\n      this.ipResult = null;\n      this.dnsHostname = null;\n      this.port = null;\n    } else {\n      if (net_1.isIPv4(hostPort.host) || net_1.isIPv6(hostPort.host)) {\n        this.ipResult = [{\n          host: hostPort.host,\n          port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT\n        }];\n        this.dnsHostname = null;\n        this.port = null;\n      } else {\n        this.ipResult = null;\n        this.dnsHostname = hostPort.host;\n        this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : DEFAULT_PORT;\n      }\n    }\n\n    this.percentage = Math.random() * 100;\n    this.defaultResolutionError = {\n      code: constants_1.Status.UNAVAILABLE,\n      details: `Name resolution failed for target ${uri_parser_1.uriToString(this.target)}`,\n      metadata: new metadata_1.Metadata()\n    };\n    const backoffOptions = {\n      initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: channelOptions['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoff = new backoff_timeout_1.BackoffTimeout(() => {\n      if (this.continueResolving) {\n        this.startResolutionWithBackoff();\n      }\n    }, backoffOptions);\n    this.backoff.unref();\n  }\n  /**\n   * If the target is an IP address, just provide that address as a result.\n   * Otherwise, initiate A, AAAA, and TXT lookups\n   */\n\n\n  startResolution() {\n    if (this.ipResult !== null) {\n      trace('Returning IP address for target ' + uri_parser_1.uriToString(this.target));\n      setImmediate(() => {\n        this.backoff.reset();\n        this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});\n      });\n      return;\n    }\n\n    if (this.dnsHostname === null) {\n      trace('Failed to parse DNS address ' + uri_parser_1.uriToString(this.target));\n      setImmediate(() => {\n        this.listener.onError({\n          code: constants_1.Status.UNAVAILABLE,\n          details: `Failed to parse DNS address ${uri_parser_1.uriToString(this.target)}`,\n          metadata: new metadata_1.Metadata()\n        });\n      });\n    } else {\n      trace('Looking up DNS hostname ' + this.dnsHostname);\n      /* We clear out latestLookupResult here to ensure that it contains the\n       * latest result since the last time we started resolving. That way, the\n       * TXT resolution handler can use it, but only if it finishes second. We\n       * don't clear out any previous service config results because it's\n       * better to use a service config that's slightly out of date than to\n       * revert to an effectively blank one. */\n\n      this.latestLookupResult = null;\n      const hostname = this.dnsHostname;\n      /* We lookup both address families here and then split them up later\n       * because when looking up a single family, dns.lookup outputs an error\n       * if the name exists but there are no records for that family, and that\n       * error is indistinguishable from other kinds of errors */\n\n      this.pendingLookupPromise = dnsLookupPromise(hostname, {\n        all: true\n      });\n      this.pendingLookupPromise.then(addressList => {\n        this.pendingLookupPromise = null;\n        this.backoff.reset();\n        const ip4Addresses = addressList.filter(addr => addr.family === 4);\n        const ip6Addresses = addressList.filter(addr => addr.family === 6);\n        this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map(addr => ({\n          host: addr.address,\n          port: +this.port\n        }));\n        const allAddressesString = '[' + this.latestLookupResult.map(addr => addr.host + ':' + addr.port).join(',') + ']';\n        trace('Resolved addresses for target ' + uri_parser_1.uriToString(this.target) + ': ' + allAddressesString);\n\n        if (this.latestLookupResult.length === 0) {\n          this.listener.onError(this.defaultResolutionError);\n          return;\n        }\n        /* If the TXT lookup has not yet finished, both of the last two\n         * arguments will be null, which is the equivalent of getting an\n         * empty TXT response. When the TXT lookup does finish, its handler\n         * can update the service config by using the same address list */\n\n\n        this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n      }, err => {\n        trace('Resolution error for target ' + uri_parser_1.uriToString(this.target) + ': ' + err.message);\n        this.pendingLookupPromise = null;\n        this.listener.onError(this.defaultResolutionError);\n      });\n      /* If there already is a still-pending TXT resolution, we can just use\n       * that result when it comes in */\n\n      if (this.pendingTxtPromise === null) {\n        /* We handle the TXT query promise differently than the others because\n         * the name resolution attempt as a whole is a success even if the TXT\n         * lookup fails */\n        this.pendingTxtPromise = resolveTxtPromise(hostname);\n        this.pendingTxtPromise.then(txtRecord => {\n          this.pendingTxtPromise = null;\n\n          try {\n            this.latestServiceConfig = service_config_1.extractAndSelectServiceConfig(txtRecord, this.percentage);\n          } catch (err) {\n            this.latestServiceConfigError = {\n              code: constants_1.Status.UNAVAILABLE,\n              details: 'Parsing service config failed',\n              metadata: new metadata_1.Metadata()\n            };\n          }\n\n          if (this.latestLookupResult !== null) {\n            /* We rely here on the assumption that calling this function with\n             * identical parameters will be essentialy idempotent, and calling\n             * it with the same address list and a different service config\n             * should result in a fast and seamless switchover. */\n            this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n          }\n        }, err => {\n          /* If TXT lookup fails we should do nothing, which means that we\n           * continue to use the result of the most recent successful lookup,\n           * or the default null config object if there has never been a\n           * successful lookup. We do not set the latestServiceConfigError\n           * here because that is specifically used for response validation\n           * errors. We still need to handle this error so that it does not\n           * bubble up as an unhandled promise rejection. */\n        });\n      }\n    }\n  }\n\n  startResolutionWithBackoff() {\n    this.startResolution();\n    this.backoff.runOnce();\n  }\n\n  updateResolution() {\n    /* If there is a pending lookup, just let it finish. Otherwise, if the\n     * backoff timer is running, do another lookup when it ends, and if not,\n     * do another lookup immeidately. */\n    if (this.pendingLookupPromise === null) {\n      if (this.backoff.isRunning()) {\n        this.continueResolving = true;\n      } else {\n        this.startResolutionWithBackoff();\n      }\n    }\n  }\n\n  destroy() {\n    /* Do nothing. There is not a practical way to cancel in-flight DNS\n     * requests, and after this function is called we can expect that\n     * updateResolution will not be called again. */\n  }\n  /**\n   * Get the default authority for the given target. For IP targets, that is\n   * the IP address. For DNS targets, it is the hostname.\n   * @param target\n   */\n\n\n  static getDefaultAuthority(target) {\n    return target.path;\n  }\n\n}\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */\n\n\nfunction setup() {\n  resolver_1.registerResolver('dns', DnsResolver);\n  resolver_1.registerDefaultScheme('dns');\n}\n\nexports.setup = setup;","map":{"version":3,"mappings":"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","names":["TRACER_NAME","trace","text","logging","constants_2","DEBUG","DEFAULT_PORT","resolveTxtPromise","util","promisify","dns","resolveTxt","dnsLookupPromise","lookup","mergeArrays","result","arrays","i","Math","max","apply","map","array","length","push","DnsResolver","constructor","target","listener","channelOptions","uri_parser_1","hostPort","path","ipResult","dnsHostname","port","net_1","host","_a","_b","percentage","random","defaultResolutionError","code","constants_1","UNAVAILABLE","details","metadata","metadata_1","backoffOptions","initialDelay","maxDelay","backoff","backoff_timeout_1","continueResolving","startResolutionWithBackoff","unref","startResolution","setImmediate","reset","onSuccessfulResolution","onError","latestLookupResult","hostname","pendingLookupPromise","all","then","addressList","ip4Addresses","filter","addr","family","ip6Addresses","address","allAddressesString","join","latestServiceConfig","latestServiceConfigError","err","message","pendingTxtPromise","txtRecord","service_config_1","runOnce","updateResolution","isRunning","destroy","getDefaultAuthority","setup","resolver_1","exports"],"sources":["/Users/ivica/Desktop/dev/face-rec/node_modules/@grpc/grpc-js/src/resolver-dns.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Resolver,\n  ResolverListener,\n  registerResolver,\n  registerDefaultScheme,\n} from './resolver';\nimport * as dns from 'dns';\nimport * as util from 'util';\nimport { extractAndSelectServiceConfig, ServiceConfig } from './service-config';\nimport { Status } from './constants';\nimport { StatusObject } from './call-stream';\nimport { Metadata } from './metadata';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport { SubchannelAddress, TcpSubchannelAddress } from './subchannel-address';\nimport { GrpcUri, uriToString, splitHostPort } from './uri-parser';\nimport { isIPv6, isIPv4 } from 'net';\nimport { ChannelOptions } from './channel-options';\nimport { BackoffOptions, BackoffTimeout } from './backoff-timeout';\n\nconst TRACER_NAME = 'dns_resolver';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\nconst DEFAULT_PORT = 443;\n\nconst resolveTxtPromise = util.promisify(dns.resolveTxt);\nconst dnsLookupPromise = util.promisify(dns.lookup);\n\n/**\n * Merge any number of arrays into a single alternating array\n * @param arrays\n */\nfunction mergeArrays<T>(...arrays: T[][]): T[] {\n  const result: T[] = [];\n  for (\n    let i = 0;\n    i <\n    Math.max.apply(\n      null,\n      arrays.map((array) => array.length)\n    );\n    i++\n  ) {\n    for (const array of arrays) {\n      if (i < array.length) {\n        result.push(array[i]);\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */\nclass DnsResolver implements Resolver {\n  private readonly ipResult: SubchannelAddress[] | null;\n  private readonly dnsHostname: string | null;\n  private readonly port: number | null;\n  private pendingLookupPromise: Promise<dns.LookupAddress[]> | null = null;\n  private pendingTxtPromise: Promise<string[][]> | null = null;\n  private latestLookupResult: TcpSubchannelAddress[] | null = null;\n  private latestServiceConfig: ServiceConfig | null = null;\n  private latestServiceConfigError: StatusObject | null = null;\n  private percentage: number;\n  private defaultResolutionError: StatusObject;\n  private backoff: BackoffTimeout;\n  private continueResolving = false;\n  constructor(\n    private target: GrpcUri,\n    private listener: ResolverListener,\n    channelOptions: ChannelOptions\n  ) {\n    trace('Resolver constructed for target ' + uriToString(target));\n    const hostPort = splitHostPort(target.path);\n    if (hostPort === null) {\n      this.ipResult = null;\n      this.dnsHostname = null;\n      this.port = null;\n    } else {\n      if (isIPv4(hostPort.host) || isIPv6(hostPort.host)) {\n        this.ipResult = [\n          {\n            host: hostPort.host,\n            port: hostPort.port ?? DEFAULT_PORT,\n          },\n        ];\n        this.dnsHostname = null;\n        this.port = null;\n      } else {\n        this.ipResult = null;\n        this.dnsHostname = hostPort.host;\n        this.port = hostPort.port ?? DEFAULT_PORT;\n      }\n    }\n    this.percentage = Math.random() * 100;\n\n    this.defaultResolutionError = {\n      code: Status.UNAVAILABLE,\n      details: `Name resolution failed for target ${uriToString(this.target)}`,\n      metadata: new Metadata(),\n    };\n    \n    const backoffOptions: BackoffOptions = {\n      initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],\n    };\n\n    this.backoff = new BackoffTimeout(() => {\n      if (this.continueResolving) {\n        this.startResolutionWithBackoff();\n      }\n    }, backoffOptions);\n    this.backoff.unref();\n  }\n\n  /**\n   * If the target is an IP address, just provide that address as a result.\n   * Otherwise, initiate A, AAAA, and TXT lookups\n   */\n  private startResolution() {\n    if (this.ipResult !== null) {\n      trace('Returning IP address for target ' + uriToString(this.target));\n      setImmediate(() => {\n        this.backoff.reset();\n        this.listener.onSuccessfulResolution(\n          this.ipResult!,\n          null,\n          null,\n          null,\n          {}\n        );\n      });\n      return;\n    }\n    if (this.dnsHostname === null) {\n      trace('Failed to parse DNS address ' + uriToString(this.target));\n      setImmediate(() => {\n        this.listener.onError({\n          code: Status.UNAVAILABLE,\n          details: `Failed to parse DNS address ${uriToString(this.target)}`,\n          metadata: new Metadata(),\n        });\n      });\n    } else {\n      trace('Looking up DNS hostname ' + this.dnsHostname);\n      /* We clear out latestLookupResult here to ensure that it contains the\n       * latest result since the last time we started resolving. That way, the\n       * TXT resolution handler can use it, but only if it finishes second. We\n       * don't clear out any previous service config results because it's\n       * better to use a service config that's slightly out of date than to\n       * revert to an effectively blank one. */\n      this.latestLookupResult = null;\n      const hostname: string = this.dnsHostname;\n      /* We lookup both address families here and then split them up later\n       * because when looking up a single family, dns.lookup outputs an error\n       * if the name exists but there are no records for that family, and that\n       * error is indistinguishable from other kinds of errors */\n      this.pendingLookupPromise = dnsLookupPromise(hostname, { all: true });\n      this.pendingLookupPromise.then(\n        (addressList) => {\n          this.pendingLookupPromise = null;\n          this.backoff.reset();\n          const ip4Addresses: dns.LookupAddress[] = addressList.filter(\n            (addr) => addr.family === 4\n          );\n          const ip6Addresses: dns.LookupAddress[] = addressList.filter(\n            (addr) => addr.family === 6\n          );\n          this.latestLookupResult = mergeArrays(\n            ip6Addresses,\n            ip4Addresses\n          ).map((addr) => ({ host: addr.address, port: +this.port! }));\n          const allAddressesString: string =\n            '[' +\n            this.latestLookupResult\n              .map((addr) => addr.host + ':' + addr.port)\n              .join(',') +\n            ']';\n          trace(\n            'Resolved addresses for target ' +\n              uriToString(this.target) +\n              ': ' +\n              allAddressesString\n          );\n          if (this.latestLookupResult.length === 0) {\n            this.listener.onError(this.defaultResolutionError);\n            return;\n          }\n          /* If the TXT lookup has not yet finished, both of the last two\n           * arguments will be null, which is the equivalent of getting an\n           * empty TXT response. When the TXT lookup does finish, its handler\n           * can update the service config by using the same address list */\n          this.listener.onSuccessfulResolution(\n            this.latestLookupResult,\n            this.latestServiceConfig,\n            this.latestServiceConfigError,\n            null,\n            {}\n          );\n        },\n        (err) => {\n          trace(\n            'Resolution error for target ' +\n              uriToString(this.target) +\n              ': ' +\n              (err as Error).message\n          );\n          this.pendingLookupPromise = null;\n          this.listener.onError(this.defaultResolutionError);\n        }\n      );\n      /* If there already is a still-pending TXT resolution, we can just use\n       * that result when it comes in */\n      if (this.pendingTxtPromise === null) {\n        /* We handle the TXT query promise differently than the others because\n         * the name resolution attempt as a whole is a success even if the TXT\n         * lookup fails */\n        this.pendingTxtPromise = resolveTxtPromise(hostname);\n        this.pendingTxtPromise.then(\n          (txtRecord) => {\n            this.pendingTxtPromise = null;\n            try {\n              this.latestServiceConfig = extractAndSelectServiceConfig(\n                txtRecord,\n                this.percentage\n              );\n            } catch (err) {\n              this.latestServiceConfigError = {\n                code: Status.UNAVAILABLE,\n                details: 'Parsing service config failed',\n                metadata: new Metadata(),\n              };\n            }\n            if (this.latestLookupResult !== null) {\n              /* We rely here on the assumption that calling this function with\n               * identical parameters will be essentialy idempotent, and calling\n               * it with the same address list and a different service config\n               * should result in a fast and seamless switchover. */\n              this.listener.onSuccessfulResolution(\n                this.latestLookupResult,\n                this.latestServiceConfig,\n                this.latestServiceConfigError,\n                null,\n                {}\n              );\n            }\n          },\n          (err) => {\n            /* If TXT lookup fails we should do nothing, which means that we\n             * continue to use the result of the most recent successful lookup,\n             * or the default null config object if there has never been a\n             * successful lookup. We do not set the latestServiceConfigError\n             * here because that is specifically used for response validation\n             * errors. We still need to handle this error so that it does not\n             * bubble up as an unhandled promise rejection. */\n          }\n        );\n      }\n    }\n  }\n\n  private startResolutionWithBackoff() {\n      this.startResolution();\n      this.backoff.runOnce();\n  }\n\n  updateResolution() {\n    /* If there is a pending lookup, just let it finish. Otherwise, if the\n     * backoff timer is running, do another lookup when it ends, and if not,\n     * do another lookup immeidately. */\n    if (this.pendingLookupPromise === null) {\n      if (this.backoff.isRunning()) {\n        this.continueResolving = true;\n      } else {\n        this.startResolutionWithBackoff();\n      }\n    }\n  }\n\n  destroy() {\n    /* Do nothing. There is not a practical way to cancel in-flight DNS\n     * requests, and after this function is called we can expect that\n     * updateResolution will not be called again. */\n  }\n\n  /**\n   * Get the default authority for the given target. For IP targets, that is\n   * the IP address. For DNS targets, it is the hostname.\n   * @param target\n   */\n  static getDefaultAuthority(target: GrpcUri): string {\n    return target.path;\n  }\n}\n\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */\nexport function setup(): void {\n  registerResolver('dns', DnsResolver);\n  registerDefaultScheme('dns');\n}\n\nexport interface DnsUrl {\n  host: string;\n  port?: string;\n}\n"]},"metadata":{},"sourceType":"script"}