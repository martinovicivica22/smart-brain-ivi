{"ast":null,"code":"let Promise = require('promise');\n\nlet validUrl = require('valid-url');\n\nlet {\n  GEO_LIMIT_TYPES,\n  ERRORS\n} = require('./constants');\n\nlet {\n  checkType,\n  clone\n} = require('./helpers');\n\nlet {\n  version: VERSION\n} = require('./../package.json');\n\nmodule.exports = {\n  wrapToken: (_config, requestFn) => {\n    return new Promise((resolve, reject) => {\n      if (_config.apiKey) {\n        let headers = {\n          Authorization: `Key ${_config.apiKey}`,\n          'X-Clarifai-Client': `js:${VERSION}`\n        };\n        return requestFn(headers).then(resolve, reject);\n      }\n\n      if (_config.sessionToken) {\n        let headers = {\n          'X-Clarifai-Session-Token': _config.sessionToken,\n          'X-Clarifai-Client': `js:${VERSION}`\n        };\n        return requestFn(headers).then(resolve, reject);\n      }\n\n      _config.token().then(token => {\n        let headers = {\n          Authorization: `Bearer ${token.accessToken}`,\n          'X-Clarifai-Client': `js:${VERSION}`\n        };\n        requestFn(headers).then(resolve, reject);\n      }, reject);\n    });\n  },\n  formatModel: function () {\n    let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let formatted = {};\n\n    if (data.id === null || data.id === undefined) {\n      throw ERRORS.paramsRequired('Model ID');\n    }\n\n    formatted.id = data.id;\n\n    if (data.name) {\n      formatted.name = data.name;\n    }\n\n    formatted.output_info = {};\n\n    if (data.conceptsMutuallyExclusive !== undefined) {\n      formatted.output_info.output_config = formatted.output_info.output_config || {};\n      formatted.output_info.output_config.concepts_mutually_exclusive = !!data.conceptsMutuallyExclusive;\n    }\n\n    if (data.closedEnvironment !== undefined) {\n      formatted.output_info.output_config = formatted.output_info.output_config || {};\n      formatted.output_info.output_config.closed_environment = !!data.closedEnvironment;\n    }\n\n    if (data.concepts) {\n      formatted.output_info.data = {\n        concepts: data.concepts.map(module.exports.formatConcept)\n      };\n    }\n\n    return formatted;\n  },\n  formatInput: (data, includeImage) => {\n    let input = checkType(/String/, data) ? {\n      url: data\n    } : data;\n    let formatted = {\n      id: input.id || null,\n      data: {}\n    };\n\n    if (input.concepts) {\n      formatted.data.concepts = input.concepts;\n    }\n\n    if (input.metadata) {\n      formatted.data.metadata = input.metadata;\n    }\n\n    if (input.geo) {\n      formatted.data.geo = {\n        geo_point: input.geo\n      };\n    }\n\n    if (input.regions) {\n      formatted.data.regions = input.regions;\n    }\n\n    if (includeImage !== false) {\n      formatted.data.image = {\n        url: input.url,\n        base64: input.base64,\n        crop: input.crop\n      };\n\n      if (data.allowDuplicateUrl) {\n        formatted.data.image.allow_duplicate_url = true;\n      }\n    }\n\n    return formatted;\n  },\n  formatMediaPredict: function (data) {\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'image';\n    let media;\n\n    if (checkType(/String/, data)) {\n      if (validUrl.isWebUri(data)) {\n        media = {\n          url: data\n        };\n      } else {\n        media = {\n          base64: data\n        };\n      }\n    } else {\n      media = Object.assign({}, data);\n    } // Users can specify their own id to distinguish batch results\n\n\n    let id;\n\n    if (media.id) {\n      id = media.id;\n      delete media.id;\n    }\n\n    let object = {\n      data: {\n        [type]: media\n      }\n    };\n\n    if (id) {\n      object.id = id;\n    }\n\n    return object;\n  },\n  formatImagesSearch: image => {\n    let imageQuery;\n    let input = {\n      input: {\n        data: {}\n      }\n    };\n    let formatted = [];\n\n    if (checkType(/String/, image)) {\n      imageQuery = {\n        url: image\n      };\n    } else {\n      imageQuery = image.url || image.base64 ? {\n        image: {\n          url: image.url,\n          base64: image.base64,\n          crop: image.crop\n        }\n      } : {};\n    }\n\n    input.input.data = imageQuery;\n\n    if (image.id) {\n      input.input.id = image.id;\n      input.input.data = {\n        image: {}\n      };\n\n      if (image.crop) {\n        input.input.data.image.crop = image.crop;\n      }\n    }\n\n    if (image.metadata !== undefined) {\n      input.input.data.metadata = image.metadata;\n    }\n\n    if (image.geo !== undefined) {\n      if (checkType(/Array/, image.geo)) {\n        input.input.data.geo = {\n          geo_box: image.geo.map(p => {\n            return {\n              geo_point: p\n            };\n          })\n        };\n      } else if (checkType(/Object/, image.geo)) {\n        if (GEO_LIMIT_TYPES.indexOf(image.geo.type) === -1) {\n          throw ERRORS.INVALID_GEOLIMIT_TYPE;\n        }\n\n        input.input.data.geo = {\n          geo_point: {\n            latitude: image.geo.latitude,\n            longitude: image.geo.longitude\n          },\n          geo_limit: {\n            type: image.geo.type,\n            value: image.geo.value\n          }\n        };\n      }\n    }\n\n    if (image.type !== 'input' && input.input.data.image) {\n      if (input.input.data.metadata || input.input.data.geo) {\n        let dataCopy = {\n          input: {\n            data: clone(input.input.data)\n          }\n        };\n        let imageCopy = {\n          input: {\n            data: clone(input.input.data)\n          }\n        };\n        delete dataCopy.input.data.image;\n        delete imageCopy.input.data.metadata;\n        delete imageCopy.input.data.geo;\n        input = [{\n          output: imageCopy\n        }, dataCopy];\n      } else {\n        input = [{\n          output: input\n        }];\n      }\n    }\n\n    formatted = formatted.concat(input);\n    return formatted;\n  },\n  formatConcept: concept => {\n    let formatted = concept;\n\n    if (checkType(/String/, concept)) {\n      formatted = {\n        id: concept\n      };\n    }\n\n    return formatted;\n  },\n  formatConceptsSearch: query => {\n    if (checkType(/String/, query)) {\n      query = {\n        id: query\n      };\n    }\n\n    let v = {};\n    let type = query.type === 'input' ? 'input' : 'output';\n    delete query.type;\n    v[type] = {\n      data: {\n        concepts: [query]\n      }\n    };\n    return v;\n  },\n\n  formatObjectForSnakeCase(obj) {\n    return Object.keys(obj).reduce((o, k) => {\n      o[k.replace(/([A-Z])/g, r => '_' + r.toLowerCase())] = obj[k];\n      return o;\n    }, {});\n  }\n\n};","map":{"version":3,"sources":["/Users/ivica/Desktop/dev/face-rec/node_modules/clarifai/src/utils.js"],"names":["Promise","require","validUrl","GEO_LIMIT_TYPES","ERRORS","checkType","clone","version","VERSION","module","exports","wrapToken","_config","requestFn","resolve","reject","apiKey","headers","Authorization","then","sessionToken","token","accessToken","formatModel","data","formatted","id","undefined","paramsRequired","name","output_info","conceptsMutuallyExclusive","output_config","concepts_mutually_exclusive","closedEnvironment","closed_environment","concepts","map","formatConcept","formatInput","includeImage","input","url","metadata","geo","geo_point","regions","image","base64","crop","allowDuplicateUrl","allow_duplicate_url","formatMediaPredict","type","media","isWebUri","Object","assign","object","formatImagesSearch","imageQuery","geo_box","p","indexOf","INVALID_GEOLIMIT_TYPE","latitude","longitude","geo_limit","value","dataCopy","imageCopy","output","concat","concept","formatConceptsSearch","query","v","formatObjectForSnakeCase","obj","keys","reduce","o","k","replace","r","toLowerCase"],"mappings":"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","sourcesContent":["let Promise = require('promise');\nlet validUrl = require('valid-url');\nlet {GEO_LIMIT_TYPES, ERRORS} = require('./constants');\nlet {checkType, clone} = require('./helpers');\nlet {version: VERSION} = require('./../package.json');\n\nmodule.exports = {\n  wrapToken: (_config, requestFn) => {\n    return new Promise((resolve, reject) => {\n      if (_config.apiKey) {\n        let headers = {\n          Authorization: `Key ${_config.apiKey}`,\n          'X-Clarifai-Client': `js:${VERSION}`\n        };\n        return requestFn(headers).then(resolve, reject);\n      }\n      if (_config.sessionToken) {\n        let headers = {\n          'X-Clarifai-Session-Token': _config.sessionToken,\n          'X-Clarifai-Client': `js:${VERSION}`\n        };\n        return requestFn(headers).then(resolve, reject);\n      }\n      _config.token().then((token) => {\n        let headers = {\n          Authorization: `Bearer ${token.accessToken}`,\n          'X-Clarifai-Client': `js:${VERSION}`\n        };\n        requestFn(headers).then(resolve, reject);\n      }, reject);\n    });\n  },\n  formatModel: (data = {}) => {\n    let formatted = {};\n    if (data.id === null || data.id === undefined) {\n      throw ERRORS.paramsRequired('Model ID');\n    }\n    formatted.id = data.id;\n    if (data.name) {\n      formatted.name = data.name;\n    }\n    formatted.output_info = {};\n    if (data.conceptsMutuallyExclusive !== undefined) {\n      formatted.output_info.output_config = formatted.output_info.output_config || {};\n      formatted.output_info.output_config.concepts_mutually_exclusive = !!data.conceptsMutuallyExclusive;\n    }\n    if (data.closedEnvironment !== undefined) {\n      formatted.output_info.output_config = formatted.output_info.output_config || {};\n      formatted.output_info.output_config.closed_environment = !!data.closedEnvironment;\n    }\n    if (data.concepts) {\n      formatted.output_info.data = {\n        concepts: data.concepts.map(module.exports.formatConcept)\n      };\n    }\n    return formatted;\n  },\n  formatInput: (data, includeImage) => {\n    let input = checkType(/String/, data) ?\n      {url: data} :\n      data;\n    let formatted = {\n      id: input.id || null,\n      data: {}\n    };\n    if (input.concepts) {\n      formatted.data.concepts = input.concepts;\n    }\n    if (input.metadata) {\n      formatted.data.metadata = input.metadata;\n    }\n    if (input.geo) {\n      formatted.data.geo = {geo_point: input.geo};\n    }\n    if (input.regions) {\n      formatted.data.regions = input.regions;\n    }\n    if (includeImage !== false) {\n      formatted.data.image = {\n        url: input.url,\n        base64: input.base64,\n        crop: input.crop\n      };\n      if (data.allowDuplicateUrl) {\n        formatted.data.image.allow_duplicate_url = true;\n      }\n    }\n    return formatted;\n  },\n  formatMediaPredict: (data, type = 'image') => {\n    let media;\n    if (checkType(/String/, data)) {\n      if (validUrl.isWebUri(data)) {\n        media = {\n          url: data\n        };\n      } else {\n        media = {\n          base64: data\n        };\n      }\n    } else {\n      media = Object.assign({}, data);\n    }\n\n    // Users can specify their own id to distinguish batch results\n    let id;\n    if (media.id) {\n      id = media.id;\n      delete media.id;\n    }\n\n    let object = {\n      data: {\n        [type]: media\n      }\n    };\n\n    if (id) {\n      object.id = id;\n    }\n\n    return object;\n  },\n  formatImagesSearch: (image) => {\n    let imageQuery;\n    let input = {input: {data: {}}};\n    let formatted = [];\n    if (checkType(/String/, image)) {\n      imageQuery = {url: image};\n    } else {\n      imageQuery = (image.url || image.base64) ? {\n        image: {\n          url: image.url,\n          base64: image.base64,\n          crop: image.crop\n        }\n      } : {};\n    }\n\n    input.input.data = imageQuery;\n    if (image.id) {\n      input.input.id = image.id;\n      input.input.data = {image: {}};\n      if(image.crop) {\n        input.input.data.image.crop = image.crop;\n      }\n    }\n    if (image.metadata !== undefined) {\n      input.input.data.metadata = image.metadata;\n    }\n    if (image.geo !== undefined) {\n      if (checkType(/Array/, image.geo)) {\n        input.input.data.geo = {\n          geo_box: image.geo.map(p => {\n            return {geo_point: p};\n          })\n        };\n      } else if (checkType(/Object/, image.geo)) {\n        if (GEO_LIMIT_TYPES.indexOf(image.geo.type) === -1) {\n          throw ERRORS.INVALID_GEOLIMIT_TYPE;\n        }\n        input.input.data.geo = {\n          geo_point: {\n            latitude: image.geo.latitude,\n            longitude: image.geo.longitude\n          },\n          geo_limit: {\n            type: image.geo.type,\n            value: image.geo.value\n          }\n        };\n      }\n    }\n    if (image.type !== 'input' && input.input.data.image) {\n      if (input.input.data.metadata || input.input.data.geo) {\n        let dataCopy = {input: {data: clone(input.input.data)}};\n        let imageCopy = {input: {data: clone(input.input.data)}};\n        delete dataCopy.input.data.image;\n        delete imageCopy.input.data.metadata;\n        delete imageCopy.input.data.geo;\n        input = [\n          {output: imageCopy},\n          dataCopy\n        ];\n      } else {\n        input = [{output: input}];\n      }\n    }\n    formatted = formatted.concat(input);\n    return formatted;\n  },\n  formatConcept: (concept) => {\n    let formatted = concept;\n    if (checkType(/String/, concept)) {\n      formatted = {\n        id: concept\n      };\n    }\n    return formatted;\n  },\n  formatConceptsSearch: (query) => {\n    if (checkType(/String/, query)) {\n      query = {id: query};\n    }\n    let v = {};\n    let type = query.type === 'input' ? 'input' : 'output';\n    delete query.type;\n    v[type] = {\n      data: {\n        concepts: [query]\n      }\n    };\n    return v;\n  },\n  formatObjectForSnakeCase(obj) {\n    return Object.keys(obj).reduce((o, k) => {\n      o[k.replace(/([A-Z])/g, r => '_'+r.toLowerCase())] = obj[k];\n      return o;\n    }, {});\n  }\n};\n"]},"metadata":{},"sourceType":"script"}