{"ast":null,"code":"let axios = require('axios');\n\nlet Concept = require('./Concept');\n\nlet {\n  API,\n  replaceVars\n} = require('./constants');\n\nlet {\n  CONCEPTS_PATH,\n  CONCEPT_PATH,\n  CONCEPT_SEARCH_PATH\n} = API;\n\nlet {\n  wrapToken,\n  formatConcept\n} = require('./utils');\n\nlet {\n  isSuccess,\n  checkType\n} = require('./helpers');\n/**\n * class representing a collection of concepts\n * @class\n */\n\n\nclass Concepts {\n  constructor(_config) {\n    let rawData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    this._config = _config;\n    this.rawData = rawData;\n    rawData.forEach((conceptData, index) => {\n      this[index] = new Concept(this._config, conceptData);\n    });\n    this.length = rawData.length;\n  }\n  /**\n   * List all the concepts\n   * @param {object}     options     Object with keys explained below: (optional)\n   *    @param {number}    options.page        The page number (optional, default: 1)\n   *    @param {number}    options.perPage     Number of images to return per page (optional, default: 20)\n   * @return {Promise(Concepts, error)} A Promise that is fulfilled with a Concepts instance or rejected with an error\n   */\n\n\n  list() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      page: 1,\n      perPage: 20\n    };\n    let url = `${this._config.basePath}${CONCEPTS_PATH}`;\n    return wrapToken(this._config, headers => {\n      return new Promise((resolve, reject) => {\n        axios.get(url, {\n          headers,\n          params: {\n            'page': options.page,\n            'per_page': options.perPage\n          }\n        }).then(response => {\n          if (isSuccess(response)) {\n            resolve(new Concepts(this._config, response.data.concepts));\n          } else {\n            reject(response);\n          }\n        }, reject);\n      });\n    });\n  }\n  /**\n   * List a single concept given an id\n   * @param {String}     id          The concept's id\n   * @return {Promise(Concept, error)} A Promise that is fulfilled with a Concept instance or rejected with an error\n   */\n\n\n  get(id) {\n    let url = `${this._config.basePath}${replaceVars(CONCEPT_PATH, [id])}`;\n    return wrapToken(this._config, headers => {\n      return new Promise((resolve, reject) => {\n        axios.get(url, {\n          headers\n        }).then(response => {\n          if (isSuccess(response)) {\n            resolve(new Concept(this._config, response.data.concept));\n          } else {\n            reject(response);\n          }\n        }, reject);\n      });\n    });\n  }\n  /**\n   * Add a list of concepts given an id and name\n   * @param {object|object[]}   concepts       Can be a single media object or an array of media objects\n   *   @param  {object|string}    concepts[].concept         If string, this is assumed to be the concept id. Otherwise, an object with the following attributes\n   *     @param  {object}           concepts[].concept.id      The new concept's id (Required)\n   *     @param  {object}           concepts[].concept.name    The new concept's name\n   * @return {Promise(Concepts, error)}             A Promise that is fulfilled with a Concepts instance or rejected with an error\n   */\n\n\n  create() {\n    let concepts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    if (checkType(/(Object|String)/, concepts)) {\n      concepts = [concepts];\n    }\n\n    let data = {\n      'concepts': concepts.map(formatConcept)\n    };\n    let url = `${this._config.basePath}${CONCEPTS_PATH}`;\n    return wrapToken(this._config, headers => {\n      return new Promise((resolve, reject) => {\n        axios.post(url, data, {\n          headers\n        }).then(response => {\n          if (isSuccess(response)) {\n            resolve(new Concepts(this._config, response.data.concepts));\n          } else {\n            reject(response);\n          }\n        }, reject);\n      });\n    });\n  }\n  /**\n   * Search for a concept given a name. A wildcard can be given (example: The name \"bo*\" will match with \"boat\" and \"bow\" given those concepts exist\n   * @param  {string}   name  The name of the concept to search for\n   * @return {Promise(Concepts, error)} A Promise that is fulfilled with a Concepts instance or rejected with an error\n   */\n\n\n  search(name) {\n    let language = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let url = `${this._config.basePath}${CONCEPT_SEARCH_PATH}`;\n    return wrapToken(this._config, headers => {\n      let params = {\n        'concept_query': {\n          name,\n          language\n        }\n      };\n      return new Promise((resolve, reject) => {\n        axios.post(url, params, {\n          headers\n        }).then(response => {\n          if (isSuccess(response)) {\n            resolve(new Concepts(this._config, response.data.concepts));\n          } else {\n            reject(response);\n          }\n        }, reject);\n      });\n    });\n  }\n  /**\n   * Update a concepts\n   * @param {object|object[]}   concepts       Can be a single concept object or an array of concept objects\n   *   @param  {object}           concepts[].concept         A concept object with the following attributes\n   *     @param  {object}           concepts[].concept.id      The concept's id (Required)\n   *     @param  {object}           concepts[].concept.name    The concept's new name\n   * @param {string}            [action=overwrite]  The action to use for the PATCH\n   * @return {Promise(Concepts, error)}             A Promise that is fulfilled with a Concepts instance or rejected with an error\n   */\n\n\n  update() {\n    let concepts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'overwrite';\n\n    if (!checkType(/Array/, concepts)) {\n      concepts = [concepts];\n    }\n\n    const data = {\n      concepts,\n      action\n    };\n    const url = `${this._config.basePath}${CONCEPTS_PATH}`;\n    return wrapToken(this._config, headers => {\n      return new Promise((resolve, reject) => {\n        axios.patch(url, data, {\n          headers\n        }).then(response => {\n          if (isSuccess(response)) {\n            resolve(new Concepts(this._config, response.data.concepts));\n          } else {\n            reject(response);\n          }\n        }, reject);\n      });\n    });\n  }\n\n}\n\n;\nmodule.exports = Concepts;","map":{"version":3,"sources":["/Users/ivica/Desktop/dev/face-rec/node_modules/clarifai/src/Concepts.js"],"names":["axios","require","Concept","API","replaceVars","CONCEPTS_PATH","CONCEPT_PATH","CONCEPT_SEARCH_PATH","wrapToken","formatConcept","isSuccess","checkType","Concepts","constructor","_config","rawData","forEach","conceptData","index","length","list","options","page","perPage","url","basePath","headers","Promise","resolve","reject","get","params","then","response","data","concepts","id","concept","create","map","post","search","name","language","update","action","patch","module","exports"],"mappings":"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","sourcesContent":["let axios = require('axios');\nlet Concept = require('./Concept');\nlet {API, replaceVars} = require('./constants');\nlet {CONCEPTS_PATH, CONCEPT_PATH, CONCEPT_SEARCH_PATH} = API;\nlet {wrapToken, formatConcept} = require('./utils');\nlet {isSuccess, checkType} = require('./helpers');\n\n/**\n * class representing a collection of concepts\n * @class\n */\nclass Concepts {\n  constructor(_config, rawData = []) {\n    this._config = _config;\n    this.rawData = rawData;\n    rawData.forEach((conceptData, index) => {\n      this[index] = new Concept(this._config, conceptData);\n    });\n    this.length = rawData.length;\n  }\n\n  /**\n   * List all the concepts\n   * @param {object}     options     Object with keys explained below: (optional)\n   *    @param {number}    options.page        The page number (optional, default: 1)\n   *    @param {number}    options.perPage     Number of images to return per page (optional, default: 20)\n   * @return {Promise(Concepts, error)} A Promise that is fulfilled with a Concepts instance or rejected with an error\n   */\n  list(options = {page: 1, perPage: 20}) {\n    let url = `${this._config.basePath}${CONCEPTS_PATH}`;\n    return wrapToken(this._config, (headers) => {\n      return new Promise((resolve, reject) => {\n        axios.get(url, {\n          headers,\n          params: {\n            'page': options.page,\n            'per_page': options.perPage,\n          }\n        }).then((response) => {\n          if (isSuccess(response)) {\n            resolve(new Concepts(this._config, response.data.concepts));\n          } else {\n            reject(response);\n          }\n        }, reject);\n      });\n    });\n  }\n\n  /**\n   * List a single concept given an id\n   * @param {String}     id          The concept's id\n   * @return {Promise(Concept, error)} A Promise that is fulfilled with a Concept instance or rejected with an error\n   */\n  get(id) {\n    let url = `${this._config.basePath}${replaceVars(CONCEPT_PATH, [id])}`;\n    return wrapToken(this._config, (headers) => {\n      return new Promise((resolve, reject) => {\n        axios.get(url, {headers}).then((response) => {\n          if (isSuccess(response)) {\n            resolve(new Concept(this._config, response.data.concept));\n          } else {\n            reject(response);\n          }\n        }, reject);\n      });\n    });\n  }\n\n  /**\n   * Add a list of concepts given an id and name\n   * @param {object|object[]}   concepts       Can be a single media object or an array of media objects\n   *   @param  {object|string}    concepts[].concept         If string, this is assumed to be the concept id. Otherwise, an object with the following attributes\n   *     @param  {object}           concepts[].concept.id      The new concept's id (Required)\n   *     @param  {object}           concepts[].concept.name    The new concept's name\n   * @return {Promise(Concepts, error)}             A Promise that is fulfilled with a Concepts instance or rejected with an error\n   */\n  create(concepts = []) {\n    if (checkType(/(Object|String)/, concepts)) {\n      concepts = [concepts];\n    }\n    let data = {\n      'concepts': concepts.map(formatConcept)\n    };\n    let url = `${this._config.basePath}${CONCEPTS_PATH}`;\n    return wrapToken(this._config, (headers) => {\n      return new Promise((resolve, reject) => {\n        axios.post(url, data, {headers})\n          .then((response) => {\n            if (isSuccess(response)) {\n              resolve(new Concepts(this._config, response.data.concepts));\n            } else {\n              reject(response);\n            }\n          }, reject);\n      });\n    });\n  }\n\n  /**\n   * Search for a concept given a name. A wildcard can be given (example: The name \"bo*\" will match with \"boat\" and \"bow\" given those concepts exist\n   * @param  {string}   name  The name of the concept to search for\n   * @return {Promise(Concepts, error)} A Promise that is fulfilled with a Concepts instance or rejected with an error\n   */\n  search(name, language = null) {\n    let url = `${this._config.basePath}${CONCEPT_SEARCH_PATH}`;\n    return wrapToken(this._config, (headers) => {\n      let params = {\n        'concept_query': {name, language}\n      };\n      return new Promise((resolve, reject) => {\n        axios.post(url, params, {headers}).then((response) => {\n          if (isSuccess(response)) {\n            resolve(new Concepts(this._config, response.data.concepts));\n          } else {\n            reject(response);\n          }\n        }, reject);\n      });\n    });\n  }\n\n  /**\n   * Update a concepts\n   * @param {object|object[]}   concepts       Can be a single concept object or an array of concept objects\n   *   @param  {object}           concepts[].concept         A concept object with the following attributes\n   *     @param  {object}           concepts[].concept.id      The concept's id (Required)\n   *     @param  {object}           concepts[].concept.name    The concept's new name\n   * @param {string}            [action=overwrite]  The action to use for the PATCH\n   * @return {Promise(Concepts, error)}             A Promise that is fulfilled with a Concepts instance or rejected with an error\n   */\n  update(concepts = [], action = 'overwrite') {\n    if (!checkType(/Array/, concepts)) {\n      concepts = [concepts];\n    }\n    const data = {\n      concepts,\n      action\n    };\n    const url = `${this._config.basePath}${CONCEPTS_PATH}`;\n    return wrapToken(this._config, headers => {\n      return new Promise((resolve, reject) => {\n        axios.patch(url, data, { headers })\n          .then((response) => {\n            if (isSuccess(response)) {\n              resolve(new Concepts(this._config, response.data.concepts));\n            } else {\n              reject(response);\n            }\n          }, reject);\n      });\n    });\n  }\n};\n\nmodule.exports = Concepts;\n"]},"metadata":{},"sourceType":"script"}